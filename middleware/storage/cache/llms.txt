---
title: Cache Storage Module
description: Distributed caching middleware for LRPC framework with Redis (go-redis/v9), Memory, BBolt, LevelDB support and Mock functionality
---

# Cache Storage Module (lrpc/middleware/storage/cache)

## 概述

`cache` 模块提供了分布式缓存存储中间件，用于 LRPC 框架。支持多种缓存后端（Redis、Memory、BBolt、LevelDB），提供统一的接口和完整的 Mock 支持。

### 核心特性
- **多后端支持**：Redis (go-redis/v9)、Memory、BBolt、LevelDB
- **丰富的数据类型**：字符串、哈希、集合、流等
- **发布订阅**：支持 Pub/Sub 消息传递
- **流处理**：支持 Redis Streams 消费者组
- **完整的 Mock 支持**：用于单元测试和本地调试
- **调用跟踪**：记录所有方法调用以支持三路测试
- **序列化支持**：JSON 和 Protobuf 数据序列化

### 应用场景
- **单元测试**：模拟缓存依赖，快速执行测试
- **集成测试**：验证缓存交互和数据一致性
- **本地调试**：无需启动 Redis 即可开发
- **演示和原型开发**：快速验证功能
- **多环境支持**：轻松切换各种缓存后端

## 快速开始

### Redis 缓存（推荐）

```go
import "github.com/lazygophers/lrpc/middleware/storage/cache"

// 使用配置创建 Redis 缓存
c, err := cache.New(&cache.Config{
    Type:     cache.Redis,
    Address:  "localhost:6379",
    Password: "",
    Db:       0,
})
defer c.Close()

// 使用外部客户端创建缓存
client := redis.NewClient(&redis.Options{Addr: "localhost:6379"})
c, err := cache.NewRedisWithClient(client, "prefix:")
```

### 内存缓存（开发/测试）

```go
c, err := cache.New(&cache.Config{
    Type: cache.Mem,
})
```

## 核心接口

### BaseCache 接口

基础缓存操作接口，提供所有缓存后端都支持的操作。

```go
type BaseCache interface {
    SetPrefix(prefix string)
    Get(key string) (string, error)
    Set(key string, value any) error
    SetEx(key string, value any, timeout time.Duration) error
    SetNx(key string, value interface{}) (bool, error)
    SetNxWithTimeout(key string, value interface{}, timeout time.Duration) (bool, error)
    Ttl(key string) (time.Duration, error)
    Expire(key string, timeout time.Duration) (bool, error)
    Incr(key string) (int64, error)
    Decr(key string) (int64, error)
    IncrBy(key string, value int64) (int64, error)
    DecrBy(key string, value int64) (int64, error)
    Exists(keys ...string) (bool, error)
    HSet(key, field string, value interface{}) (bool, error)
    HGet(key, field string) (string, error)
    HDel(key string, fields ...string) (int64, error)
    HKeys(key string) ([]string, error)
    HGetAll(key string) (map[string]string, error)
    HExists(key, field string) (bool, error)
    HIncr(key, subKey string) (int64, error)
    HIncrBy(key, field string, increment int64) (int64, error)
    HDecr(key, field string) (int64, error)
    HDecrBy(key, field string, increment int64) (int64, error)
    SAdd(key string, members ...string) (int64, error)
    SMembers(key string) ([]string, error)
    SRem(key string, members ...string) (int64, error)
    SRandMember(key string, count ...int64) ([]string, error)
    SPop(key string) (string, error)
    SisMember(key, field string) (bool, error)
    Publish(channel string, message interface{}) (int64, error)
    Subscribe(handler func(channel string, message []byte) error, channels ...string) error
    XAdd(stream string, values map[string]interface{}) (string, error)
    XLen(stream string) (int64, error)
    XRange(stream, start, stop string, count ...int64) ([]map[string]interface{}, error)
    XRevRange(stream, start, stop string, count ...int64) ([]map[string]interface{}, error)
    XDel(stream string, ids ...string) (int64, error)
    XTrim(stream string, maxLen int64) (int64, error)
    XGroupCreate(stream, group, start string) error
    XGroupDestroy(stream, group string) error
    XGroupSetID(stream, group, id string) error
    XReadGroup(handler func(stream string, id string, body []byte) error, group, consumer, stream string) error
    XAck(stream, group string, ids ...string) (int64, error)
    XPending(stream, group string) (int64, error)
    Del(key ...string) error
    Clean() error
    Close() error
    Ping() error
}
```

### Cache 接口

扩展缓存接口，提供高级数据转换和序列化操作。

```go
type Cache interface {
    BaseCache
    Base() BaseCache
    GetBool(key string) (bool, error)
    GetInt(key string) (int, error)
    GetUint(key string) (uint, error)
    GetInt32(key string) (int32, error)
    GetUint32(key string) (uint32, error)
    GetInt64(key string) (int64, error)
    GetUint64(key string) (uint64, error)
    GetFloat32(key string) (float32, error)
    GetFloat64(key string) (float64, error)
    GetSlice(key string) ([]string, error)
    GetBoolSlice(key string) ([]bool, error)
    GetIntSlice(key string) ([]int, error)
    GetUintSlice(key string) ([]uint, error)
    GetInt32Slice(key string) ([]int32, error)
    GetUint32Slice(key string) ([]uint32, error)
    GetInt64Slice(key string) ([]int64, error)
    GetUint64Slice(key string) ([]uint64, error)
    GetFloat32Slice(key string) ([]float32, error)
    GetFloat64Slice(key string) ([]float64, error)
    GetJson(key string, j interface{}) error
    SetPb(key string, j proto.Message) error
    SetPbEx(key string, j proto.Message, timeout time.Duration) error
    GetPb(key string, j proto.Message) error
    HGetJson(key, field string, j interface{}) error
    Limit(key string, limit int64, timeout time.Duration) (bool, error)
    LimitUpdateOnCheck(key string, limit int64, timeout time.Duration) (bool, error)
}
```

## Redis 实现

### 使用 go-redis/v9

```go
import (
    "github.com/lazygophers/lrpc/middleware/storage/cache"
    "github.com/redis/go-redis/v9"
)

// 方式1：使用配置创建
c, err := cache.New(&cache.Config{
    Type:     cache.Redis,
    Address:  "localhost:6379",
    Password: "",
    Db:       0,
})
defer c.Close()

// 方式2：使用已有客户端
client := redis.NewClient(&redis.Options{
    Addr:     "localhost:6379",
    Password: "",
    DB:       0,
})
c, err := cache.NewRedisWithClient(client, "app:")
```

### 配置选项

```go
type Config struct {
    Type     string // "mem", "redis", "bbolt", "leveldb", "sugardb"
    Address  string // 服务器地址
    Password string // 密码
    Db       int    // 数据库编号
    DataDir  string // 数据目录
}
```

### Redis 连接池配置

```go
client := redis.NewClient(&redis.Options{
    Addr:         "localhost:6379",
    Password:     "",
    DB:           0,
    PoolSize:     1000,      // 连接池大小
    MinIdleConns: 100,       // 最小空闲连接
    DialTimeout:  5 * time.Second,
    ReadTimeout:  3 * time.Second,
    WriteTimeout: 3 * time.Second,
    PoolTimeout:  4 * time.Second,
})
```

## Mock 支持

### MockCache - 完整模拟

用于模拟 Cache 接口的所有操作。

```go
// 创建 Mock 缓存
mockCache := NewMockCache()

// 设置返回值
mockCache.SetupSuccess().GetRet = "cached_value"

// 执行操作
val, err := mockCache.Get("mykey")

// 验证调用
assert.True(t, mockCache.AssertCalled("Get"))
assert.Equal(t, 1, mockCache.GetCallCount("Get"))
```

**Key Setup Methods:**

```go
// 通用设置
SetupSuccess() *MockCache         // 所有操作成功
SetupError(err error) *MockCache  // 设置统一错误

// KV 操作设置
GetRet string
GetErr error
SetErr error
SetExErr error
SetNxRet bool
SetNxErr error

// 数值操作设置
IncrRet int64
IncrErr error
DecrRet int64
DecrErr error

// 哈希操作设置
HSetRet bool
HSetErr error
HGetRet string
HGetErr error
HGetAllRet map[string]string
HGetAllErr error

// 集合操作设置
SAddRet int64
SAddErr error
SMembersRet []string
SMembersErr error

// 流操作设置
XAddRet string
XAddErr error
XLenRet int64
XLenErr error
XRangeRet []map[string]interface{}
XRangeErr error

// 类型转换设置
GetBoolRet bool
GetBoolErr error
GetIntRet int
GetIntErr error
GetInt64Ret int64
GetInt64Err error
// ... 更多类型

// 序列化设置
GetJsonErr error
SetPbErr error
GetPbErr error

// 限流设置
LimitRet bool
LimitErr error

// 数据存储（用于测试缓存命中场景）
SetData(key string, value interface{}) *MockCache          // 设置 JSON 序列化数据
SetHashData(key, field string, value interface{}) *MockCache // 设置哈希字段数据
SetJsonString(key, jsonStr string) *MockCache               // 直接设置 JSON 字符串
SetPbData(key string, data []byte) *MockCache               // 设置 Protobuf 字节数据

// 调用跟踪
GetCalls() []CallRecord
GetCallCount(method string) int
AssertCalled(method string) bool
AssertNotCalled(method string) bool
ResetCalls()
```

## 使用示例

### Redis 流操作

```go
c, _ := cache.New(&cache.Config{Type: cache.Redis, Address: "localhost:6379"})
defer c.Close()

// 添加消息到流
id, _ := c.XAdd("events", map[string]interface{}{
    "type": "user_login",
    "user": "john",
})

// 创建消费者组
_ = c.XGroupCreate("events", "handlers", "0")

// 消费消息
go c.XReadGroup(func(stream, id, body []byte) error {
    fmt.Printf("Received: %s\n", body)
    return nil
}, "handlers", "consumer1", "events")
```

### 发布订阅

```go
// 发布者
c.Publish("updates", "new data available")

// 订阅者
go c.Subscribe(func(channel string, message []byte) error {
    fmt.Printf("Channel: %s, Message: %s\n", channel, message)
    return nil
}, "updates")
```

### 单元测试示例

```go
func TestUserService(t *testing.T) {
    // 创建 Mock 缓存
    mockCache := cache.NewMockCache()
    mockCache.SetupSuccess().GetRet = "cached_user"

    // 初始化服务
    service := NewUserService(mockCache)

    // 执行测试
    user, err := service.GetUser("1")
    require.NoError(t, err)
    require.Equal(t, "cached_user", user)

    // 验证调用
    require.Equal(t, 1, mockCache.GetCallCount("Get"))
}
```

## 缓存后端对比

| 后端 | 特性 | 用途 | 持久化 |
|------|------|------|--------|
| Redis (go-redis/v9) | 分布式、高性能、丰富数据类型 | 生产环境 | 可选 |
| Memory | 简单、快速、无网络 | 单机开发、测试 | 否 |
| BBolt | 嵌入式、事务支持 | 本地存储 | 是 |
| LevelDB | 高性能、LSM 树 | 时间序列、日志 | 是 |

## 最佳实践

1. **总是关闭连接**：使用 `defer cache.Close()`
2. **检查健康状态**：在启动时执行 `Ping()` 检查
3. **使用 Mock 测试**：为所有缓存操作编写 Mock 测试
4. **设置合理的过期时间**：避免缓存无限增长
5. **环境切换**：使用环境变量切换不同的缓存后端
6. **错误处理**：始终检查错误返回值
7. **性能优化**：使用批量操作而非逐条操作

## 参考资源

- [go-redis/v9 文档](https://redis.uptrace.dev/)
- [Redis 文档](https://redis.io/documentation)
- [LRPC 框架](https://github.com/lazygophers/lrpc)

## 版本历史

- v2.0.0: 从 redigo 迁移到 go-redis/v9
  - 完全重写 Redis 实现
  - 使用 context.Context
  - 更新 API 调用方式
  - 保持接口兼容性

- v1.0.0: 初始发布（基于 redigo）
