
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>mongo: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/lazygophers/lrpc/middleware/storage/mongo/aggregation.go (92.3%)</option>
				
				<option value="file1">github.com/lazygophers/lrpc/middleware/storage/mongo/client.go (85.7%)</option>
				
				<option value="file2">github.com/lazygophers/lrpc/middleware/storage/mongo/cond.go (88.5%)</option>
				
				<option value="file3">github.com/lazygophers/lrpc/middleware/storage/mongo/config.go (100.0%)</option>
				
				<option value="file4">github.com/lazygophers/lrpc/middleware/storage/mongo/log.go (100.0%)</option>
				
				<option value="file5">github.com/lazygophers/lrpc/middleware/storage/mongo/model.go (90.9%)</option>
				
				<option value="file6">github.com/lazygophers/lrpc/middleware/storage/mongo/model_scoop.go (98.2%)</option>
				
				<option value="file7">github.com/lazygophers/lrpc/middleware/storage/mongo/scoop.go (85.6%)</option>
				
				<option value="file8">github.com/lazygophers/lrpc/middleware/storage/mongo/stream.go (81.8%)</option>
				
				<option value="file9">github.com/lazygophers/lrpc/middleware/storage/mongo/sub_cond.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package mongo

import (
        "context"

        "go.mongodb.org/mongo-driver/bson"
        "go.mongodb.org/mongo-driver/mongo"
        "go.mongodb.org/mongo-driver/mongo/options"
)

// Aggregation represents a MongoDB aggregation pipeline
type Aggregation struct {
        coll     *mongo.Collection
        ctx      context.Context
        pipeline bson.A
        opts     *options.AggregateOptions
}

// NewAggregation creates a new aggregation pipeline
func NewAggregation(coll *mongo.Collection, ctx context.Context, stages ...bson.M) *Aggregation <span class="cov8" title="1">{
        pipeline := bson.A{}
        for _, stage := range stages </span><span class="cov8" title="1">{
                pipeline = append(pipeline, stage)
        }</span>

        <span class="cov8" title="1">return &amp;Aggregation{
                coll:     coll,
                ctx:      ctx,
                pipeline: pipeline,
                opts:     options.Aggregate(),
        }</span>
}

// Match adds a $match stage
func (a *Aggregation) Match(filter bson.M) *Aggregation <span class="cov8" title="1">{
        a.pipeline = append(a.pipeline, bson.M{"$match": filter})
        return a
}</span>

// Project adds a $project stage
func (a *Aggregation) Project(projection bson.M) *Aggregation <span class="cov8" title="1">{
        a.pipeline = append(a.pipeline, bson.M{"$project": projection})
        return a
}</span>

// Group adds a $group stage
func (a *Aggregation) Group(groupBy bson.M) *Aggregation <span class="cov8" title="1">{
        a.pipeline = append(a.pipeline, bson.M{"$group": groupBy})
        return a
}</span>

// Sort adds a $sort stage
func (a *Aggregation) Sort(sort bson.M) *Aggregation <span class="cov8" title="1">{
        a.pipeline = append(a.pipeline, bson.M{"$sort": sort})
        return a
}</span>

// Skip adds a $skip stage
func (a *Aggregation) Skip(skip int64) *Aggregation <span class="cov8" title="1">{
        a.pipeline = append(a.pipeline, bson.M{"$skip": skip})
        return a
}</span>

// Limit adds a $limit stage
func (a *Aggregation) Limit(limit int64) *Aggregation <span class="cov8" title="1">{
        a.pipeline = append(a.pipeline, bson.M{"$limit": limit})
        return a
}</span>

// Lookup adds a $lookup stage (join)
func (a *Aggregation) Lookup(from string, localField string, foreignField string, as string) *Aggregation <span class="cov8" title="1">{
        a.pipeline = append(a.pipeline, bson.M{
                "$lookup": bson.M{
                        "from":         from,
                        "localField":   localField,
                        "foreignField": foreignField,
                        "as":           as,
                },
        })
        return a
}</span>

// Unwind adds an $unwind stage
func (a *Aggregation) Unwind(path string, preserveNullAndEmptyArrays ...bool) *Aggregation <span class="cov8" title="1">{
        unwindStage := bson.M{"$unwind": bson.M{"path": path}}
        if len(preserveNullAndEmptyArrays) &gt; 0 </span><span class="cov8" title="1">{
                unwindMap := unwindStage["$unwind"].(bson.M)
                unwindMap["preserveNullAndEmptyArrays"] = preserveNullAndEmptyArrays[0]
        }</span>
        <span class="cov8" title="1">a.pipeline = append(a.pipeline, unwindStage)
        return a</span>
}

// AddFields adds an $addFields stage
func (a *Aggregation) AddFields(fields bson.M) *Aggregation <span class="cov8" title="1">{
        a.pipeline = append(a.pipeline, bson.M{"$addFields": fields})
        return a
}</span>

// Count adds a $count stage
func (a *Aggregation) Count(field string) *Aggregation <span class="cov8" title="1">{
        a.pipeline = append(a.pipeline, bson.M{"$count": field})
        return a
}</span>

// Facet adds a $facet stage
func (a *Aggregation) Facet(facets bson.M) *Aggregation <span class="cov8" title="1">{
        a.pipeline = append(a.pipeline, bson.M{"$facet": facets})
        return a
}</span>

// AddStage adds a custom stage to the pipeline
func (a *Aggregation) AddStage(stage bson.M) *Aggregation <span class="cov8" title="1">{
        a.pipeline = append(a.pipeline, stage)
        return a
}</span>

// Execute executes the aggregation pipeline
func (a *Aggregation) Execute(result interface{}) error <span class="cov8" title="1">{
        cursor, err := a.coll.Aggregate(a.ctx, a.pipeline, a.opts)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer cursor.Close(a.ctx)

        err = cursor.All(a.ctx, result)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// ExecuteOne executes the aggregation pipeline and returns a single result
func (a *Aggregation) ExecuteOne(result interface{}) error <span class="cov8" title="1">{
        cursor, err := a.coll.Aggregate(a.ctx, a.pipeline, a.opts)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer cursor.Close(a.ctx)

        if cursor.Next(a.ctx) </span><span class="cov8" title="1">{
                err := cursor.Decode(result)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">return cursor.Err()</span>
}

// GetPipeline returns the aggregation pipeline
func (a *Aggregation) GetPipeline() bson.A <span class="cov8" title="1">{
        return a.pipeline
}</span>

// Clear clears the pipeline
func (a *Aggregation) Clear() *Aggregation <span class="cov8" title="1">{
        a.pipeline = bson.A{}
        return a
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package mongo

import (
        "context"
        "fmt"

        "github.com/kamva/mgm/v3"
        "github.com/lazygophers/log"
        "go.mongodb.org/mongo-driver/mongo"
)

// Client represents a MongoDB client wrapper using MGM
type Client struct {
        cfg      *Config
        client   *mongo.Client
        database string
}

// New creates a new MongoDB client with the given configuration
func New(cfg *Config) (*Client, error) <span class="cov8" title="1">{
        if cfg == nil </span><span class="cov8" title="1">{
                cfg = &amp;Config{}
        }</span>

        // Apply defaults
        <span class="cov8" title="1">cfg.apply()

        // Build MongoDB client options
        opts := cfg.BuildClientOpts()

        // Initialize MGM with configuration
        err := mgm.SetDefaultConfig(&amp;mgm.Config{}, cfg.Database, opts)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("err:%v", err)
                return nil, err
        }</span>

        // Get the MongoDB client from MGM to verify connection
        <span class="cov8" title="1">_, mongoClient, _, err := mgm.DefaultConfigs()
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("err:%v", err)
                return nil, err
        }</span>

        // Ping to verify connection
        <span class="cov8" title="1">err = mongoClient.Ping(context.Background(), nil)
        if err != nil </span><span class="cov8" title="1">{
                log.Errorf("err:%v", err)
                return nil, err
        }</span>

        <span class="cov8" title="1">c := &amp;Client{
                cfg:      cfg,
                client:   mongoClient,
                database: cfg.Database,
        }

        log.Infof("successfully connected to MongoDB: %s:%d", cfg.Address, cfg.Port)

        return c, nil</span>
}

// Ping checks the connection to MongoDB
func (c *Client) Ping() error <span class="cov8" title="1">{
        _, client, _, err := mgm.DefaultConfigs()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return client.Ping(context.Background(), nil)</span>
}

// Close closes the MongoDB client connection
func (c *Client) Close() error <span class="cov8" title="1">{
        _, client, _, err := mgm.DefaultConfigs()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if client != nil </span><span class="cov8" title="1">{
                err := client.Disconnect(context.Background())
                if err != nil </span><span class="cov8" title="1">{
                        log.Errorf("err:%v", err)
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// GetConfig returns the client configuration
func (c *Client) GetConfig() *Config <span class="cov8" title="1">{
        return c.cfg
}</span>

// Context returns the operation context
func (c *Client) Context() context.Context <span class="cov8" title="1">{
        return context.Background()
}</span>

// GetDatabase returns the database name
func (c *Client) GetDatabase() string <span class="cov8" title="1">{
        if c.cfg.Database == "" </span><span class="cov8" title="1">{
                return "test"
        }</span>
        <span class="cov8" title="1">return c.cfg.Database</span>
}

// Health checks the health of the connection
func (c *Client) Health() error <span class="cov8" title="1">{
        err := c.Ping()
        if err != nil </span><span class="cov8" title="1">{
                log.Errorf("err:%v", err)
                return fmt.Errorf("health check failed: %w", err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package mongo

import (
        "fmt"
        "reflect"
        "strings"

        "go.mongodb.org/mongo-driver/bson"
)

// Cond is a MongoDB condition builder for constructing complex queries
// Similar to db/cond.go but generates BSON instead of SQL
type Cond struct {
        conds []bson.M
        isOr  bool

        // skip marks conditions that should not execute queries
        skip bool
}

// NewCond creates a new Cond for building conditions
func NewCond() *Cond <span class="cov8" title="1">{
        return &amp;Cond{}
}</span>

// addCond adds a simple field condition (field: {$op: value})
func (p *Cond) addCond(fieldName, op string, val interface{}) <span class="cov8" title="1">{
        if fieldName == "" </span><span class="cov0" title="0">{
                panic("fieldName empty")</span>
        }
        <span class="cov8" title="1">if op == "" </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("empty op for field %s", fieldName))</span>
        }

        // Simple equality condition: field: value
        <span class="cov8" title="1">if op == "=" || op == "$eq" </span><span class="cov8" title="1">{
                p.conds = append(p.conds, bson.M{fieldName: val})
                return
        }</span>

        // Other operators: field: {$op: value}
        <span class="cov8" title="1">mongoOp := op
        if !strings.HasPrefix(op, "$") </span><span class="cov8" title="1">{
                mongoOp = "$" + op
        }</span>
        <span class="cov8" title="1">p.conds = append(p.conds, bson.M{fieldName: bson.M{mongoOp: val}})</span>
}

// addSubWhere adds a sub-condition (nested OR/AND group)
func (p *Cond) addSubWhere(isOr bool, args ...interface{}) <span class="cov8" title="1">{
        subCond := &amp;Cond{
                isOr: isOr,
        }
        subCond.where(args...)
        if len(subCond.conds) == 0 </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">subBson := subCond.ToBson()
        if subBson == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">p.conds = append(p.conds, subBson)</span>
}

// where supports multiple calling forms:
//   - map[string]interface{} with field names as keys
//   - []interface{} with mixed elements
//   - field name, value pairs (assumed equality)
//   - *Cond for nested conditions
func (p *Cond) where(args ...interface{}) <span class="cov8" title="1">{
        if len(args) == 0 </span><span class="cov8" title="1">{
                return
        }</span>

        // Handle *Cond as argument
        <span class="cov8" title="1">if cond, ok := args[0].(*Cond); ok </span><span class="cov8" title="1">{
                bsonCond := cond.ToBson()
                if bsonCond != nil </span><span class="cov8" title="1">{
                        p.conds = append(p.conds, bsonCond)
                }</span>
                <span class="cov8" title="1">p.where(args[1:]...)
                return</span>
        }

        <span class="cov8" title="1">arg0 := reflect.ValueOf(args[0])
        for arg0.Kind() == reflect.Interface || arg0.Kind() == reflect.Ptr </span><span class="cov0" title="0">{
                arg0 = arg0.Elem()
        }</span>

        <span class="cov8" title="1">switch arg0.Kind() </span>{
        case reflect.Bool:<span class="cov8" title="1">
                v := arg0.Bool()
                if !v </span><span class="cov8" title="1">{
                        p.skip = true
                }</span>

        case reflect.String:<span class="cov8" title="1">
                fieldName := arg0.String()
                var op string
                var val interface{}

                if len(args) == 2 </span><span class="cov8" title="1">{
                        // fieldName, value -&gt; equality
                        fieldName, op = getOp(fieldName)
                        val = args[1]
                        p.addCond(fieldName, op, val)
                }</span> else<span class="cov8" title="1"> if len(args) == 3 </span><span class="cov8" title="1">{
                        // fieldName, op, value
                        op = reflect.ValueOf(args[1]).String()
                        val = args[2]
                        p.addCond(fieldName, op, val)
                }</span> else<span class="cov8" title="1"> if len(args) == 1 </span>{<span class="cov8" title="1">
                        // Just a field name string - skip
                        // This might be a raw MongoDB condition string
                }</span> else<span class="cov0" title="0"> {
                        panic(fmt.Sprintf("invalid number of where args %d by `string` prefix", len(args)))</span>
                }

        case reflect.Map:<span class="cov8" title="1">
                typ := arg0.Type()
                if typ.Key().Kind() != reflect.String </span><span class="cov0" title="0">{
                        panic(fmt.Sprintf("map key type required string, but got %v", typ.Key()))</span>
                }
                <span class="cov8" title="1">for _, k := range arg0.MapKeys() </span><span class="cov8" title="1">{
                        fieldName := k.String()
                        val := arg0.MapIndex(k)
                        if !val.IsValid() || !val.CanInterface() </span><span class="cov0" title="0">{
                                panic(fmt.Sprintf("invalid map val for field %s", fieldName))</span>
                        }
                        <span class="cov8" title="1">var op string
                        fieldName, op = getOp(fieldName)
                        p.addCond(fieldName, op, val.Interface())</span>
                }
                <span class="cov8" title="1">if len(args) &gt; 1 </span><span class="cov8" title="1">{
                        p.where(args[1:]...)
                }</span>

        case reflect.Slice, reflect.Array:<span class="cov8" title="1">
                n := arg0.Len()
                if n == 0 </span><span class="cov8" title="1">{
                        break</span>
                }
                // Check if first element is string (then it's a condition)
                <span class="cov8" title="1">{
                        v := arg0.Index(0)
                        if v.Kind() == reflect.String </span><span class="cov0" title="0">{
                                list := make([]interface{}, 0, n)
                                for i := 0; i &lt; n; i++ </span><span class="cov0" title="0">{
                                        vv := arg0.Index(i)
                                        if !vv.CanInterface() </span><span class="cov0" title="0">{
                                                panic("slice element can't convert to interface")</span>
                                        }
                                        <span class="cov0" title="0">list = append(list, vv.Interface())</span>
                                }
                                <span class="cov0" title="0">p.where(list...)
                                if len(args) &gt; 1 </span><span class="cov0" title="0">{
                                        p.where(args[1:]...)
                                }</span>
                                <span class="cov0" title="0">break</span>
                        }
                }
                // Process each element in the slice
                <span class="cov8" title="1">for i := 0; i &lt; n; i++ </span><span class="cov8" title="1">{
                        v := arg0.Index(i)
                        for v.Kind() == reflect.Interface || v.Kind() == reflect.Ptr </span><span class="cov8" title="1">{
                                v = v.Elem()
                        }</span>
                        <span class="cov8" title="1">vk := v.Kind()
                        if vk == reflect.Map </span><span class="cov8" title="1">{
                                p.addSubWhere(false, v.Interface())
                        }</span> else<span class="cov8" title="1"> {
                                var list []interface{}
                                if vk == reflect.Slice || vk == reflect.Array </span><span class="cov8" title="1">{
                                        vLen := v.Len()
                                        list = make([]interface{}, 0, vLen)
                                        for ii := 0; ii &lt; vLen; ii++ </span><span class="cov8" title="1">{
                                                vv := v.Index(ii)
                                                if !vv.CanInterface() </span><span class="cov0" title="0">{
                                                        panic("slice element can't convert to interface")</span>
                                                }
                                                <span class="cov8" title="1">list = append(list, vv.Interface())</span>
                                        }
                                } else<span class="cov8" title="1"> {
                                        if !v.CanInterface() </span><span class="cov0" title="0">{
                                                panic("slice element can't convert to interface")</span>
                                        }
                                        <span class="cov8" title="1">list = make([]interface{}, 1)
                                        list[0] = v.Interface()</span>
                                }
                                <span class="cov8" title="1">p.where(list...)</span>
                        }
                }

        default:<span class="cov0" title="0">
                panic(fmt.Sprintf("unhandled type: %v", arg0.Type()))</span>
        }
}

// ToBson converts the condition to a BSON query
// Returns nil if no conditions were added
func (p *Cond) ToBson() bson.M <span class="cov8" title="1">{
        if len(p.conds) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">if len(p.conds) == 1 </span><span class="cov8" title="1">{
                return p.conds[0]
        }</span>

        <span class="cov8" title="1">if p.isOr </span><span class="cov8" title="1">{
                return bson.M{"$or": p.conds}
        }</span>
        // AND: merge all conditions
        <span class="cov8" title="1">result := bson.M{}
        for _, cond := range p.conds </span><span class="cov8" title="1">{
                for k, v := range cond </span><span class="cov8" title="1">{
                        result[k] = v
                }</span>
        }
        <span class="cov8" title="1">return result</span>
}

// Where adds AND conditions
func (p *Cond) Where(args ...interface{}) *Cond <span class="cov8" title="1">{
        p.addSubWhere(false, args...)
        return p
}</span>

// OrWhere adds OR conditions
func (p *Cond) OrWhere(args ...interface{}) *Cond <span class="cov8" title="1">{
        p.addSubWhere(true, args...)
        return p
}</span>

// Or is an alias for OrWhere
func (p *Cond) Or(args ...interface{}) *Cond <span class="cov8" title="1">{
        p.addSubWhere(true, args...)
        return p
}</span>

// Equal adds an equality condition
func (p *Cond) Equal(column string, value interface{}) *Cond <span class="cov8" title="1">{
        p.where(column, "=", value)
        return p
}</span>

// Ne adds a != condition using $ne operator
func (p *Cond) Ne(column string, value interface{}) *Cond <span class="cov8" title="1">{
        p.where(column, "$ne", value)
        return p
}</span>

// Gt adds a &gt; condition using $gt operator
func (p *Cond) Gt(column string, value interface{}) *Cond <span class="cov8" title="1">{
        p.where(column, "$gt", value)
        return p
}</span>

// Lt adds a &lt; condition using $lt operator
func (p *Cond) Lt(column string, value interface{}) *Cond <span class="cov8" title="1">{
        p.where(column, "$lt", value)
        return p
}</span>

// Gte adds a &gt;= condition using $gte operator
func (p *Cond) Gte(column string, value interface{}) *Cond <span class="cov8" title="1">{
        p.where(column, "$gte", value)
        return p
}</span>

// Lte adds a &lt;= condition using $lte operator
func (p *Cond) Lte(column string, value interface{}) *Cond <span class="cov8" title="1">{
        p.where(column, "$lte", value)
        return p
}</span>

// In adds an $in condition
func (p *Cond) In(column string, values ...interface{}) *Cond <span class="cov8" title="1">{
        p.where(column, "$in", values)
        return p
}</span>

// NotIn adds a $nin condition
func (p *Cond) NotIn(column string, values ...interface{}) *Cond <span class="cov8" title="1">{
        p.where(column, "$nin", values)
        return p
}</span>

// Like adds a $regex condition (case-insensitive)
func (p *Cond) Like(column string, pattern string) *Cond <span class="cov8" title="1">{
        if pattern == "" </span><span class="cov8" title="1">{
                return p
        }</span>
        <span class="cov8" title="1">p.conds = append(p.conds, bson.M{
                column: bson.M{
                        "$regex":   pattern,
                        "$options": "i",
                },
        })
        return p</span>
}

// LeftLike adds a $regex condition with pattern%
func (p *Cond) LeftLike(column string, pattern string) *Cond <span class="cov8" title="1">{
        if pattern == "" </span><span class="cov8" title="1">{
                return p
        }</span>
        <span class="cov8" title="1">p.conds = append(p.conds, bson.M{
                column: bson.M{
                        "$regex":   pattern + ".*",
                        "$options": "i",
                },
        })
        return p</span>
}

// RightLike adds a $regex condition with %pattern
func (p *Cond) RightLike(column string, pattern string) *Cond <span class="cov8" title="1">{
        if pattern == "" </span><span class="cov8" title="1">{
                return p
        }</span>
        <span class="cov8" title="1">p.conds = append(p.conds, bson.M{
                column: bson.M{
                        "$regex":   ".*" + pattern,
                        "$options": "i",
                },
        })
        return p</span>
}

// NotLike adds a $not $regex condition
func (p *Cond) NotLike(column string, pattern string) *Cond <span class="cov8" title="1">{
        if pattern == "" </span><span class="cov8" title="1">{
                return p
        }</span>
        <span class="cov8" title="1">p.conds = append(p.conds, bson.M{
                column: bson.M{
                        "$not": bson.M{
                                "$regex":   pattern,
                                "$options": "i",
                        },
                },
        })
        return p</span>
}

// NotLeftLike adds a $not $regex condition with pattern%
func (p *Cond) NotLeftLike(column string, pattern string) *Cond <span class="cov8" title="1">{
        if pattern == "" </span><span class="cov8" title="1">{
                return p
        }</span>
        <span class="cov8" title="1">p.conds = append(p.conds, bson.M{
                column: bson.M{
                        "$not": bson.M{
                                "$regex":   pattern + ".*",
                                "$options": "i",
                        },
                },
        })
        return p</span>
}

// NotRightLike adds a $not $regex condition with %pattern
func (p *Cond) NotRightLike(column string, pattern string) *Cond <span class="cov8" title="1">{
        if pattern == "" </span><span class="cov8" title="1">{
                return p
        }</span>
        <span class="cov8" title="1">p.conds = append(p.conds, bson.M{
                column: bson.M{
                        "$not": bson.M{
                                "$regex":   ".*" + pattern,
                                "$options": "i",
                        },
                },
        })
        return p</span>
}

// Between adds a condition for values between min and max (inclusive)
func (p *Cond) Between(column string, min, max interface{}) *Cond <span class="cov8" title="1">{
        p.conds = append(p.conds, bson.M{
                column: bson.M{
                        "$gte": min,
                        "$lte": max,
                },
        })
        return p
}</span>

// NotBetween adds a condition for values not between min and max
func (p *Cond) NotBetween(column string, min, max interface{}) *Cond <span class="cov8" title="1">{
        p.conds = append(p.conds, bson.M{
                column: bson.M{
                        "$not": bson.M{
                                "$gte": min,
                                "$lte": max,
                        },
                },
        })
        return p
}</span>

// Reset clears all conditions and resets the Cond to its initial state
func (p *Cond) Reset() *Cond <span class="cov8" title="1">{
        p.conds = p.conds[:0]
        p.isOr = false
        p.skip = false
        return p
}</span>

// String returns a string representation of the condition for debugging
// Converts the condition to BSON and returns its string representation
func (p *Cond) String() string <span class="cov8" title="1">{
        bsonCond := p.ToBson()
        if bsonCond == nil </span><span class="cov8" title="1">{
                return "{}"
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf("%v", bsonCond)</span>
}

// getOp extracts operator from field name
// Examples: "age &gt;" -&gt; ("age", "&gt;"), "name LIKE" -&gt; ("name", "LIKE")
func getOp(fieldName string) (newFieldName, op string) <span class="cov8" title="1">{
        op = "="
        newFieldName = fieldName

        // Find the first invalid character (space, operator char)
        idx := getFirstInvalidFieldNameCharIndex(fieldName)
        if idx &gt; 0 </span><span class="cov8" title="1">{
                o := strings.TrimSpace(fieldName[idx:])
                newFieldName = fieldName[:idx]
                if o != "" </span><span class="cov8" title="1">{
                        op = o
                }</span>
        }
        <span class="cov8" title="1">return</span>
}

// getFirstInvalidFieldNameCharIndex finds the first non-field-name character
func getFirstInvalidFieldNameCharIndex(s string) int <span class="cov8" title="1">{
        for i := 0; i &lt; len(s); i++ </span><span class="cov8" title="1">{
                c := s[i]
                // Valid characters: alphanumeric, underscore, dot
                if (c &gt;= 'a' &amp;&amp; c &lt;= 'z') || (c &gt;= 'A' &amp;&amp; c &lt;= 'Z') || (c &gt;= '0' &amp;&amp; c &lt;= '9') ||
                        c == '_' || c == '.' </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">return i</span>
        }
        <span class="cov8" title="1">return -1</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package mongo

import (
        "fmt"
        "time"

        "go.mongodb.org/mongo-driver/mongo/options"
)

// Config represents MongoDB configuration
type Config struct {
        // MongoDB server address, default 127.0.0.1
        Address string `yaml:"address,omitempty" json:"address,omitempty"`

        // MongoDB server port, default 27017
        Port int `yaml:"port,omitempty" json:"port,omitempty"`

        // Database name, default test
        Database string `yaml:"database,omitempty" json:"database,omitempty"`

        // MongoDB username for authentication
        Username string `yaml:"username,omitempty" json:"username,omitempty"`

        // MongoDB password for authentication
        Password string `yaml:"password,omitempty" json:"password,omitempty"`

        // Authentication database (default: admin)
        AuthSource string `yaml:"auth_source,omitempty" json:"auth_source,omitempty"`

        // Replica set name (optional)
        ReplicaSet string `yaml:"replica_set,omitempty" json:"replica_set,omitempty"`

        // Debug mode - enables verbose logging
        Debug bool `yaml:"debug,omitempty" json:"debug,omitempty"`

        // Connection timeout, default 10 seconds
        ConnectTimeout time.Duration `yaml:"connect_timeout,omitempty" json:"connect_timeout,omitempty"`

        // Context timeout for operations, default 30 seconds
        ContextTimeout time.Duration `yaml:"context_timeout,omitempty" json:"context_timeout,omitempty"`

        // Max connection pool size, default 100
        MaxPoolSize uint64 `yaml:"max_pool_size,omitempty" json:"max_pool_size,omitempty"`

        // Min connection pool size, default 10
        MinPoolSize uint64 `yaml:"min_pool_size,omitempty" json:"min_pool_size,omitempty"`

        // Max connection idle time, default 5 minutes
        MaxConnIdleTime time.Duration `yaml:"max_conn_idle_time,omitempty" json:"max_conn_idle_time,omitempty"`

        // Logger interface for custom logging (for SQL output)
        Logger Logger `json:"-" yaml:"-"`
}

// apply applies default values to the configuration
func (c *Config) apply() <span class="cov8" title="1">{
        if c.Logger == nil </span><span class="cov8" title="1">{
                c.Logger = GetDefaultLogger()
        }</span>

        <span class="cov8" title="1">if c.Address == "" </span><span class="cov8" title="1">{
                c.Address = "127.0.0.1"
        }</span>

        <span class="cov8" title="1">if c.Port == 0 </span><span class="cov8" title="1">{
                c.Port = 27017
        }</span>

        <span class="cov8" title="1">if c.ConnectTimeout &lt;= 0 </span><span class="cov8" title="1">{
                c.ConnectTimeout = 10 * time.Second
        }</span>

        <span class="cov8" title="1">if c.ContextTimeout &lt;= 0 </span><span class="cov8" title="1">{
                c.ContextTimeout = 30 * time.Second
        }</span>

        <span class="cov8" title="1">if c.MaxPoolSize == 0 </span><span class="cov8" title="1">{
                c.MaxPoolSize = 100
        }</span>

        <span class="cov8" title="1">if c.MinPoolSize == 0 </span><span class="cov8" title="1">{
                c.MinPoolSize = 10
        }</span>

        <span class="cov8" title="1">if c.MaxConnIdleTime == 0 </span><span class="cov8" title="1">{
                c.MaxConnIdleTime = 5 * time.Minute
        }</span>
}

// buildURI builds MongoDB connection URI from config
func (c *Config) buildURI() string <span class="cov8" title="1">{
        uri := "mongodb://"

        // Add credentials if provided
        if c.Username != "" &amp;&amp; c.Password != "" </span><span class="cov8" title="1">{
                uri += fmt.Sprintf("%s:%s@", c.Username, c.Password)
        }</span>

        // Add host and port
        <span class="cov8" title="1">uri += fmt.Sprintf("%s:%d", c.Address, c.Port)

        // Build query parameters
        var params []string

        if c.ReplicaSet != "" </span><span class="cov8" title="1">{
                params = append(params, fmt.Sprintf("replicaSet=%s", c.ReplicaSet))
        }</span>

        <span class="cov8" title="1">if c.AuthSource != "" </span><span class="cov8" title="1">{
                params = append(params, fmt.Sprintf("authSource=%s", c.AuthSource))
        }</span>

        <span class="cov8" title="1">if len(params) &gt; 0 </span><span class="cov8" title="1">{
                uri += "/?" + params[0]
                for _, param := range params[1:] </span><span class="cov8" title="1">{
                        uri += "&amp;" + param
                }</span>
        } else<span class="cov8" title="1"> {
                uri += "/"
        }</span>

        <span class="cov8" title="1">return uri</span>
}

// BuildClientOpts builds MongoDB client options from config
func (c *Config) BuildClientOpts() *options.ClientOptions <span class="cov8" title="1">{
        opts := options.Client().
                ApplyURI(c.buildURI()).
                SetMaxConnIdleTime(c.MaxConnIdleTime).
                SetMaxPoolSize(c.MaxPoolSize).
                SetMinPoolSize(c.MinPoolSize)

        return opts
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package mongo

import (
        "sync"

        "github.com/lazygophers/log"
)

// Logger interface for MongoDB logging (for SQL output)
type Logger interface {
        Infof(format string, args ...interface{})
        Warnf(format string, args ...interface{})
        Errorf(format string, args ...interface{})
        Debugf(format string, args ...interface{})
}

type logger struct {
        logger *log.Logger
}

var (
        syncOnce sync.Once
        _logger  Logger
)

// GetDefaultLogger returns a default logger if not set
func GetDefaultLogger() Logger <span class="cov8" title="1">{
        syncOnce.Do(func() </span><span class="cov8" title="1">{
                if _logger == nil </span><span class="cov8" title="1">{
                        _logger = NewLogger()
                }</span>
        })
        <span class="cov8" title="1">return _logger</span>
}

// SetDefaultLogger sets the default logger
func SetDefaultLogger(l Logger) <span class="cov8" title="1">{
        _logger = l
}</span>

// NewLogger creates a new logger
func NewLogger() Logger <span class="cov8" title="1">{
        return &amp;logger{
                logger: log.Clone().SetCallerDepth(5),
        }
}</span>

// Infof logs an info message
func (l *logger) Infof(format string, args ...interface{}) <span class="cov8" title="1">{
        l.logger.Infof(format, args...)
}</span>

// Warnf logs a warning message
func (l *logger) Warnf(format string, args ...interface{}) <span class="cov8" title="1">{
        l.logger.Warnf(format, args...)
}</span>

// Errorf logs an error message
func (l *logger) Errorf(format string, args ...interface{}) <span class="cov8" title="1">{
        l.logger.Errorf(format, args...)
}</span>

// Debugf logs a debug message
func (l *logger) Debugf(format string, args ...interface{}) <span class="cov8" title="1">{
        l.logger.Debugf(format, args...)
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package mongo

import "go.mongodb.org/mongo-driver/mongo"

// Collectioner interface for models that can provide their collection name
type Collectioner interface {
        Collection() string
}

// Model[M] is a lightweight model wrapper managing model metadata and client reference
type Model[M Collectioner] struct {
        client         *Client
        model          M
        collectionName string
        notFoundError  error
}

// NewModel creates a new model wrapper
func NewModel[M Collectioner](client *Client, model M) *Model[M] <span class="cov8" title="1">{
        return &amp;Model[M]{
                client:         client,
                model:          model,
                collectionName: model.Collection(),
                notFoundError:  mongo.ErrNoDocuments,
        }
}</span>

// NewScoop creates a type-safe query builder for this model, optionally accepting a transaction scoop
func (m *Model[M]) NewScoop(tx ...*Scoop) *ModelScoop[M] <span class="cov8" title="1">{
        var baseScoop *Scoop
        if len(tx) &gt; 0 &amp;&amp; tx[0] != nil </span><span class="cov0" title="0">{
                baseScoop = m.client.NewScoop(tx[0]).CollectionName(m.collectionName)
        }</span> else<span class="cov8" title="1"> {
                baseScoop = m.client.NewScoop().CollectionName(m.collectionName)
        }</span>

        <span class="cov8" title="1">baseScoop.SetNotFound(m.notFoundError)

        return &amp;ModelScoop[M]{
                Scoop: baseScoop,
                m:     m.model,
        }</span>
}

// CollectionName returns the collection name for this model
func (m *Model[M]) CollectionName() string <span class="cov8" title="1">{
        return m.collectionName
}</span>

// SetNotFound sets the not found error for this model
func (m *Model[M]) SetNotFound(err error) *Model[M] <span class="cov8" title="1">{
        m.notFoundError = err
        return m
}</span>

// IsNotFound checks if the error is a not found error
func (m *Model[M]) IsNotFound(err error) bool <span class="cov8" title="1">{
        return err == m.notFoundError || err == mongo.ErrNoDocuments
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package mongo

import (
        "go.mongodb.org/mongo-driver/bson"
        "go.mongodb.org/mongo-driver/mongo"
)

// ModelScoop[M] is a type-safe query builder wrapping Scoop with model-specific methods
type ModelScoop[M any] struct {
        *Scoop
        m M
}

// Find finds documents matching the filter and returns typed results
func (ms *ModelScoop[M]) Find() ([]M, error) <span class="cov8" title="1">{
        var results []M
        err := ms.Scoop.Find(&amp;results)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return results, nil</span>
}

// First finds a single document matching the filter
func (ms *ModelScoop[M]) First() (*M, error) <span class="cov8" title="1">{
        var result M
        err := ms.Scoop.First(&amp;result)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;result, nil</span>
}

// Count counts documents matching the filter
func (ms *ModelScoop[M]) Count() (int64, error) <span class="cov8" title="1">{
        ms.Scoop.Collection(ms.m)
        return ms.Scoop.Count()
}</span>

// Create creates a new document
func (ms *ModelScoop[M]) Create(doc M) error <span class="cov8" title="1">{
        return ms.Scoop.Create(doc)
}</span>

// Update updates documents matching the filter
func (ms *ModelScoop[M]) Update(update interface{}) (int64, error) <span class="cov8" title="1">{
        ms.Scoop.Collection(ms.m)
        return ms.Scoop.Update(update)
}</span>

// Delete deletes documents matching the filter
func (ms *ModelScoop[M]) Delete() (int64, error) <span class="cov8" title="1">{
        ms.Scoop.Collection(ms.m)
        return ms.Scoop.Delete()
}</span>

// Exist checks if documents matching the filter exist
func (ms *ModelScoop[M]) Exist() (bool, error) <span class="cov8" title="1">{
        ms.Scoop.Collection(ms.m)
        return ms.Scoop.Exist()
}</span>

// Watch watches for changes on this model's collection
func (ms *ModelScoop[M]) Watch(pipeline ...bson.M) (*ChangeStream, error) <span class="cov8" title="1">{
        return ms.Scoop.WatchChanges(pipeline...)
}</span>

// Aggregate creates an aggregation pipeline for this model
func (ms *ModelScoop[M]) Aggregate(pipeline ...bson.M) *Aggregation <span class="cov8" title="1">{
        return ms.Scoop.Aggregate(pipeline...)
}</span>

// GetCollection returns the underlying MongoDB collection
func (ms *ModelScoop[M]) GetCollection() *mongo.Collection <span class="cov8" title="1">{
        return ms.Scoop.GetCollection()
}</span>

// GetScoop returns the underlying Scoop for advanced operations
func (ms *ModelScoop[M]) GetScoop() *Scoop <span class="cov8" title="1">{
        return ms.Scoop
}</span>

// Where adds a filter condition
func (ms *ModelScoop[M]) Where(key string, value interface{}) *ModelScoop[M] <span class="cov8" title="1">{
        ms.Scoop.Where(key, value)
        return ms
}</span>

// Limit sets the result limit
func (ms *ModelScoop[M]) Limit(limit int64) *ModelScoop[M] <span class="cov8" title="1">{
        ms.Scoop.Limit(limit)
        return ms
}</span>

// Offset sets the result offset
func (ms *ModelScoop[M]) Offset(offset int64) *ModelScoop[M] <span class="cov8" title="1">{
        ms.Scoop.Offset(offset)
        return ms
}</span>

// Sort adds sorting
// direction: 1 for ascending (default), -1 for descending
func (ms *ModelScoop[M]) Sort(key string, direction ...int) *ModelScoop[M] <span class="cov8" title="1">{
        ms.Scoop.Sort(key, direction...)
        return ms
}</span>

// Select specifies which fields to return
func (ms *ModelScoop[M]) Select(fields ...string) *ModelScoop[M] <span class="cov8" title="1">{
        ms.Scoop.Select(fields...)
        return ms
}</span>

// Equal adds an equality condition
func (ms *ModelScoop[M]) Equal(key string, value interface{}) *ModelScoop[M] <span class="cov8" title="1">{
        ms.Scoop.Equal(key, value)
        return ms
}</span>

// Ne adds a != condition using $ne operator
func (ms *ModelScoop[M]) Ne(key string, value interface{}) *ModelScoop[M] <span class="cov8" title="1">{
        ms.Scoop.Ne(key, value)
        return ms
}</span>

// In adds an $in condition
func (ms *ModelScoop[M]) In(key string, values ...interface{}) *ModelScoop[M] <span class="cov8" title="1">{
        ms.Scoop.In(key, values...)
        return ms
}</span>

// NotIn adds a $nin condition
func (ms *ModelScoop[M]) NotIn(key string, values ...interface{}) *ModelScoop[M] <span class="cov8" title="1">{
        ms.Scoop.NotIn(key, values...)
        return ms
}</span>

// Like adds a regex pattern match (case-insensitive)
func (ms *ModelScoop[M]) Like(key string, pattern string) *ModelScoop[M] <span class="cov8" title="1">{
        ms.Scoop.Like(key, pattern)
        return ms
}</span>

// Gt adds a &gt; condition using $gt operator
func (ms *ModelScoop[M]) Gt(key string, value interface{}) *ModelScoop[M] <span class="cov8" title="1">{
        ms.Scoop.Gt(key, value)
        return ms
}</span>

// Lt adds a &lt; condition using $lt operator
func (ms *ModelScoop[M]) Lt(key string, value interface{}) *ModelScoop[M] <span class="cov8" title="1">{
        ms.Scoop.Lt(key, value)
        return ms
}</span>

// Gte adds a &gt;= condition using $gte operator
func (ms *ModelScoop[M]) Gte(key string, value interface{}) *ModelScoop[M] <span class="cov8" title="1">{
        ms.Scoop.Gte(key, value)
        return ms
}</span>

// Lte adds a &lt;= condition using $lte operator
func (ms *ModelScoop[M]) Lte(key string, value interface{}) *ModelScoop[M] <span class="cov8" title="1">{
        ms.Scoop.Lte(key, value)
        return ms
}</span>

// Between adds a $gte and $lte condition
func (ms *ModelScoop[M]) Between(key string, min interface{}, max interface{}) *ModelScoop[M] <span class="cov8" title="1">{
        ms.Scoop.Between(key, min, max)
        return ms
}</span>

// Skip is an alias for Offset
func (ms *ModelScoop[M]) Skip(skip int64) *ModelScoop[M] <span class="cov8" title="1">{
        return ms.Offset(skip)
}</span>

// Clear resets the scoop
func (ms *ModelScoop[M]) Clear() *ModelScoop[M] <span class="cov8" title="1">{
        ms.Scoop.Clear()
        return ms
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package mongo

import (
        "context"
        "encoding/json"
        "fmt"
        "reflect"

        "github.com/kamva/mgm/v3"
        "github.com/lazygophers/log"
        "go.mongodb.org/mongo-driver/bson"
        "go.mongodb.org/mongo-driver/mongo"
        "go.mongodb.org/mongo-driver/mongo/options"
)

// Scoop is a generic MongoDB query builder for simplified operations
type Scoop struct {
        client        *Client
        coll          *mongo.Collection
        filter        *Cond
        limit         *int64
        offset        *int64
        sort          bson.M
        projection    bson.M
        session       mongo.Session
        notFoundError error
}

// NewScoop creates a new scoop instance, optionally accepting a transaction scoop
func (c *Client) NewScoop(tx ...*Scoop) *Scoop <span class="cov8" title="1">{
        scoop := &amp;Scoop{
                client:        c,
                filter:        NewCond(),
                sort:          bson.M{},
                projection:    bson.M{},
                notFoundError: mongo.ErrNoDocuments,
        }

        // If a transaction scoop is provided, inherit its session and notFoundError
        if len(tx) &gt; 0 &amp;&amp; tx[0] != nil </span><span class="cov0" title="0">{
                scoop.session = tx[0].session
        }</span>

        <span class="cov8" title="1">return scoop</span>
}

// getCollectionNameFromOut 从 out 参数的类型推导集合名
func (s *Scoop) getCollectionNameFromOut(out interface{}) string <span class="cov8" title="1">{
        if out == nil </span><span class="cov8" title="1">{
                return ""
        }</span>

        // 反射获取类型
        <span class="cov8" title="1">outType := reflect.TypeOf(out)

        // 如果是指针，获取指向的类型
        for outType.Kind() == reflect.Ptr </span><span class="cov8" title="1">{
                outType = outType.Elem()
        }</span>

        // 如果是 slice，获取元素类型
        <span class="cov8" title="1">if outType.Kind() == reflect.Slice || outType.Kind() == reflect.Array </span><span class="cov8" title="1">{
                outType = outType.Elem()
                for outType.Kind() == reflect.Ptr </span><span class="cov0" title="0">{
                        outType = outType.Elem()
                }</span>
        }

        // 尝试调用 Collection() 方法
        <span class="cov8" title="1">outValue := reflect.New(outType)
        if m := outValue.MethodByName("Collection"); m.IsValid() </span><span class="cov8" title="1">{
                result := m.Call(nil)
                if len(result) &gt; 0 &amp;&amp; result[0].Kind() == reflect.String </span><span class="cov8" title="1">{
                        if collName := result[0].String(); collName != "" </span><span class="cov8" title="1">{
                                return collName
                        }</span>
                }
        }

        // 默认使用类型名称
        <span class="cov0" title="0">return outType.Name()</span>
}

// getCollection retrieves a MongoDB collection using MGM
func (s *Scoop) getCollection(collName string) *mongo.Collection <span class="cov8" title="1">{
        mgmColl := mgm.CollectionByName(collName)
        // MGM Collection embeds *mongo.Collection
        return mgmColl.Collection
}</span>

// ensureCollection 确保 Scoop 有关联的集合
func (s *Scoop) ensureCollection(out interface{}) error <span class="cov8" title="1">{
        if s.coll != nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">collName := s.getCollectionNameFromOut(out)
        if collName == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("cannot determine collection name from out parameter")
        }</span>

        <span class="cov8" title="1">s.coll = s.getCollection(collName)
        return nil</span>
}

// Collection 设置要操作的集合
// getContext returns the appropriate context for this scoop
// If a session exists, it wraps the session in a SessionContext
// Otherwise, returns a background context
func (s *Scoop) getContext() context.Context <span class="cov8" title="1">{
        if s.session != nil </span><span class="cov8" title="1">{
                return mongo.NewSessionContext(context.Background(), s.session)
        }</span>
        <span class="cov8" title="1">return context.Background()</span>
}

func (s *Scoop) Collection(model interface{}) *Scoop <span class="cov8" title="1">{
        collName := s.getCollectionNameFromOut(model)
        if collName != "" </span><span class="cov8" title="1">{
                s.coll = s.getCollection(collName)
        }</span>
        <span class="cov8" title="1">return s</span>
}

// CollectionName sets the collection by name string
func (s *Scoop) CollectionName(name string) *Scoop <span class="cov8" title="1">{
        if name != "" </span><span class="cov8" title="1">{
                s.coll = s.getCollection(name)
        }</span>
        <span class="cov8" title="1">return s</span>
}

// Where adds filter conditions to the scoop
// Supports multiple calling forms:
//   - Where(key string, value interface{}) - simple equality condition
//   - Where(key string, op string, value interface{}) - with operator
//   - Where(cond *Cond) - condition builder
func (s *Scoop) Where(args ...interface{}) *Scoop <span class="cov8" title="1">{
        if len(args) == 0 </span><span class="cov8" title="1">{
                return s
        }</span>

        // Delegate to Cond.where() which handles all cases including *Cond
        <span class="cov8" title="1">s.filter.where(args...)
        return s</span>
}

// Equal adds an equality condition
func (s *Scoop) Equal(key string, value interface{}) *Scoop <span class="cov8" title="1">{
        s.filter.Equal(key, value)
        return s
}</span>

// Ne adds a != condition using $ne operator
func (s *Scoop) Ne(key string, value interface{}) *Scoop <span class="cov8" title="1">{
        s.filter.Ne(key, value)
        return s
}</span>

// In adds an $in condition
func (s *Scoop) In(key string, values ...interface{}) *Scoop <span class="cov8" title="1">{
        s.filter.In(key, values...)
        return s
}</span>

// NotIn adds a $nin condition
func (s *Scoop) NotIn(key string, values ...interface{}) *Scoop <span class="cov8" title="1">{
        s.filter.NotIn(key, values...)
        return s
}</span>

// Like adds a regex pattern match (case-insensitive)
func (s *Scoop) Like(key string, pattern string) *Scoop <span class="cov8" title="1">{
        s.filter.Like(key, pattern)
        return s
}</span>

// Gt adds a &gt; condition using $gt operator
func (s *Scoop) Gt(key string, value interface{}) *Scoop <span class="cov8" title="1">{
        s.filter.Gt(key, value)
        return s
}</span>

// Lt adds a &lt; condition using $lt operator
func (s *Scoop) Lt(key string, value interface{}) *Scoop <span class="cov8" title="1">{
        s.filter.Lt(key, value)
        return s
}</span>

// Gte adds a &gt;= condition using $gte operator
func (s *Scoop) Gte(key string, value interface{}) *Scoop <span class="cov8" title="1">{
        s.filter.Gte(key, value)
        return s
}</span>

// Lte adds a &lt;= condition using $lte operator
func (s *Scoop) Lte(key string, value interface{}) *Scoop <span class="cov8" title="1">{
        s.filter.Lte(key, value)
        return s
}</span>

// Between adds a $gte and $lte condition
func (s *Scoop) Between(key string, min interface{}, max interface{}) *Scoop <span class="cov8" title="1">{
        s.filter.Between(key, min, max)
        return s
}</span>

// Limit sets the limit
func (s *Scoop) Limit(limit int64) *Scoop <span class="cov8" title="1">{
        s.limit = &amp;limit
        return s
}</span>

// Offset sets the offset/skip
func (s *Scoop) Offset(offset int64) *Scoop <span class="cov8" title="1">{
        s.offset = &amp;offset
        return s
}</span>

// Skip is an alias for Offset
func (s *Scoop) Skip(skip int64) *Scoop <span class="cov8" title="1">{
        return s.Offset(skip)
}</span>

// Sort adds sorting
// direction: 1 for ascending (default), -1 for descending
func (s *Scoop) Sort(key string, direction ...int) *Scoop <span class="cov8" title="1">{
        dir := 1 // default ascending
        if len(direction) &gt; 0 </span><span class="cov8" title="1">{
                dir = direction[0]
        }</span>
        <span class="cov8" title="1">s.sort[key] = dir
        return s</span>
}

// Select specifies which fields to return
func (s *Scoop) Select(fields ...string) *Scoop <span class="cov8" title="1">{
        for _, field := range fields </span><span class="cov8" title="1">{
                s.projection[field] = 1
        }</span>
        <span class="cov8" title="1">return s</span>
}

// Find finds documents matching the filter
func (s *Scoop) Find(result interface{}) error <span class="cov8" title="1">{
        err := s.ensureCollection(result)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("err:%v", err)
                return err
        }</span>

        // Build FindOptions from scoop fields
        <span class="cov8" title="1">opts := options.Find()
        if s.limit != nil </span><span class="cov8" title="1">{
                opts.SetLimit(*s.limit)
        }</span>
        <span class="cov8" title="1">if s.offset != nil </span><span class="cov8" title="1">{
                opts.SetSkip(*s.offset)
        }</span>
        <span class="cov8" title="1">if len(s.sort) &gt; 0 </span><span class="cov8" title="1">{
                opts.SetSort(s.sort)
        }</span>
        <span class="cov8" title="1">if len(s.projection) &gt; 0 </span><span class="cov8" title="1">{
                opts.SetProjection(s.projection)
        }</span>

        <span class="cov8" title="1">ctx := s.getContext()
        cursor, err := s.coll.Find(ctx, s.filter.ToBson(), opts)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("err:%v", err)
                return err
        }</span>
        <span class="cov8" title="1">defer cursor.Close(ctx)

        err = cursor.All(ctx, result)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("err:%v", err)
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// First finds a single document, returns error if not found
func (s *Scoop) First(result interface{}) error <span class="cov8" title="1">{
        err := s.ensureCollection(result)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("err:%v", err)
                return err
        }</span>

        <span class="cov8" title="1">ctx := s.getContext()
        opts := options.FindOne()
        if len(s.projection) &gt; 0 </span><span class="cov8" title="1">{
                opts.SetProjection(s.projection)
        }</span>
        <span class="cov8" title="1">sr := s.coll.FindOne(ctx, s.filter.ToBson(), opts)
        if sr.Err() != nil </span><span class="cov8" title="1">{
                log.Errorf("err:%v", sr.Err())
                return sr.Err()
        }</span>

        <span class="cov8" title="1">err = sr.Decode(result)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("err:%v", err)
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// Count counts documents matching the filter
func (s *Scoop) Count() (int64, error) <span class="cov8" title="1">{
        count, err := s.coll.CountDocuments(s.getContext(), s.filter.ToBson())
        if err != nil </span><span class="cov8" title="1">{
                log.Errorf("err:%v", err)
                return 0, err
        }</span>

        <span class="cov8" title="1">return count, nil</span>
}

// Exist checks if documents matching the filter exist by fetching only _id field
func (s *Scoop) Exist() (bool, error) <span class="cov8" title="1">{
        // Clone scoop and select only _id field for efficiency
        scoop := s.Clone()
        scoop.Select("_id")

        ctx := scoop.getContext()
        opts := options.FindOne()
        opts.SetProjection(scoop.projection)

        sr := scoop.coll.FindOne(ctx, scoop.filter.ToBson(), opts)
        if sr.Err() != nil </span><span class="cov8" title="1">{
                if sr.Err() == mongo.ErrNoDocuments </span><span class="cov8" title="1">{
                        return false, nil
                }</span>
                <span class="cov0" title="0">log.Errorf("err:%v", sr.Err())
                return false, sr.Err()</span>
        }

        <span class="cov8" title="1">return true, nil</span>
}

// Create inserts a new document
func (s *Scoop) Create(doc interface{}) error <span class="cov8" title="1">{
        err := s.ensureCollection(doc)
        if err != nil </span><span class="cov8" title="1">{
                log.Errorf("err:%v", err)
                return err
        }</span>

        <span class="cov8" title="1">_, err = s.coll.InsertOne(s.getContext(), doc)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("err:%v", err)
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// BatchCreate inserts multiple documents
func (s *Scoop) BatchCreate(docs ...interface{}) error <span class="cov8" title="1">{
        if len(docs) == 0 </span><span class="cov8" title="1">{
                err := fmt.Errorf("no documents to insert")
                log.Errorf("err:%v", err)
                return err
        }</span>

        <span class="cov8" title="1">err := s.ensureCollection(docs[0])
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("err:%v", err)
                return err
        }</span>

        <span class="cov8" title="1">_, err = s.coll.InsertMany(s.getContext(), docs)
        if err != nil </span><span class="cov8" title="1">{
                log.Errorf("err:%v", err)
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// Update updates documents matching the filter
func (s *Scoop) Update(update interface{}) (int64, error) <span class="cov8" title="1">{
        if s.coll == nil </span><span class="cov8" title="1">{
                err := fmt.Errorf("collection not set, call Collection(model) or use Find/Create first")
                log.Errorf("err:%v", err)
                return 0, err
        }</span>

        <span class="cov8" title="1">updateDoc := bson.M{}

        // If update is a map, wrap it in $set
        switch v := update.(type) </span>{
        case bson.M:<span class="cov8" title="1">
                if _, ok := v["$set"]; !ok &amp;&amp; len(v) &gt; 0 </span><span class="cov8" title="1">{
                        updateDoc = bson.M{"$set": v}
                }</span> else<span class="cov8" title="1"> {
                        updateDoc = v
                }</span>
        case map[string]interface{}:<span class="cov8" title="1">
                // Check if it has update operators
                hasOperator := false
                for key := range v </span><span class="cov8" title="1">{
                        if len(key) &gt; 0 &amp;&amp; key[0] == '$' </span><span class="cov8" title="1">{
                                hasOperator = true
                                break</span>
                        }
                }
                <span class="cov8" title="1">if !hasOperator </span><span class="cov8" title="1">{
                        updateDoc = bson.M{"$set": v}
                }</span> else<span class="cov8" title="1"> {
                        updateDoc = bson.M(v)
                }</span>
        default:<span class="cov8" title="1">
                // Convert to map via JSON
                data, err := json.Marshal(v)
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("err:%v", err)
                        return 0, err
                }</span>

                <span class="cov8" title="1">var m map[string]interface{}
                err = json.Unmarshal(data, &amp;m)
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("err:%v", err)
                        return 0, err
                }</span>

                <span class="cov8" title="1">updateDoc = bson.M{"$set": m}</span>
        }

        <span class="cov8" title="1">result, err := s.coll.UpdateMany(s.getContext(), s.filter.ToBson(), updateDoc)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("err:%v", err)
                return 0, err
        }</span>

        <span class="cov8" title="1">return result.ModifiedCount, nil</span>
}

// Delete deletes documents matching the filter
func (s *Scoop) Delete() (int64, error) <span class="cov8" title="1">{
        result, err := s.coll.DeleteMany(s.getContext(), s.filter.ToBson())
        if err != nil </span><span class="cov8" title="1">{
                log.Errorf("err:%v", err)
                return 0, err
        }</span>

        <span class="cov8" title="1">return result.DeletedCount, nil</span>
}

// Aggregate creates an aggregation pipeline
func (s *Scoop) Aggregate(pipeline ...bson.M) *Aggregation <span class="cov8" title="1">{
        return NewAggregation(s.coll, s.getContext(), pipeline...)
}</span>

// Clone creates a copy of the scoop with current state
func (s *Scoop) Clone() *Scoop <span class="cov8" title="1">{
        newScoop := &amp;Scoop{
                client:        s.client,
                coll:          s.coll,
                filter:        NewCond(),
                sort:          bson.M{},
                projection:    bson.M{},
                session:       s.session,
                notFoundError: s.notFoundError,
        }

        // Deep copy filter conditions
        if s.filter != nil &amp;&amp; len(s.filter.conds) &gt; 0 </span><span class="cov8" title="1">{
                newScoop.filter.conds = make([]bson.M, len(s.filter.conds))
                for i, cond := range s.filter.conds </span><span class="cov8" title="1">{
                        // Deep copy each BSON condition
                        newScoop.filter.conds[i] = make(bson.M)
                        for k, v := range cond </span><span class="cov8" title="1">{
                                newScoop.filter.conds[i][k] = v
                        }</span>
                }
                <span class="cov8" title="1">newScoop.filter.isOr = s.filter.isOr</span>
        }

        // Copy limit and offset
        <span class="cov8" title="1">if s.limit != nil </span><span class="cov8" title="1">{
                newScoop.limit = s.limit
        }</span>
        <span class="cov8" title="1">if s.offset != nil </span><span class="cov0" title="0">{
                newScoop.offset = s.offset
        }</span>

        // Deep copy sort
        <span class="cov8" title="1">if len(s.sort) &gt; 0 </span><span class="cov8" title="1">{
                newScoop.sort = make(bson.M)
                for k, v := range s.sort </span><span class="cov8" title="1">{
                        newScoop.sort[k] = v
                }</span>
        }

        // Deep copy projection
        <span class="cov8" title="1">if len(s.projection) &gt; 0 </span><span class="cov0" title="0">{
                newScoop.projection = make(bson.M)
                for k, v := range s.projection </span><span class="cov0" title="0">{
                        newScoop.projection[k] = v
                }</span>
        }

        <span class="cov8" title="1">return newScoop</span>
}

// Clear resets the scoop
func (s *Scoop) Clear() *Scoop <span class="cov8" title="1">{
        s.filter = NewCond()
        s.limit = nil
        s.offset = nil
        s.sort = bson.M{}
        s.projection = bson.M{}
        return s
}</span>

// GetCollection returns the underlying MongoDB collection
func (s *Scoop) GetCollection() *mongo.Collection <span class="cov8" title="1">{
        return s.coll
}</span>

// SetNotFound sets the not found error for this scoop
func (s *Scoop) SetNotFound(err error) *Scoop <span class="cov8" title="1">{
        s.notFoundError = err
        return s
}</span>

// IsNotFound checks if the error is a not found error
func (s *Scoop) IsNotFound(err error) bool <span class="cov8" title="1">{
        return err == s.notFoundError || err == mongo.ErrNoDocuments
}</span>

// Begin starts a transaction - creates session lazily if needed
func (s *Scoop) Begin() (*Scoop, error) <span class="cov8" title="1">{
        // Lazy initialization: create session only when needed
        if s.session == nil </span><span class="cov8" title="1">{
                _, mongoClient, _, err := mgm.DefaultConfigs()
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("err:%v", err)
                        return nil, err
                }</span>

                <span class="cov8" title="1">session, err := mongoClient.StartSession()
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("err:%v", err)
                        return nil, err
                }</span>

                <span class="cov8" title="1">s.session = session</span>
        }

        // Start transaction on the session
        <span class="cov8" title="1">err := s.session.StartTransaction()
        if err != nil </span><span class="cov8" title="1">{
                log.Errorf("err:%v", err)
                return nil, err
        }</span>

        // Return a new Scoop with the same session (for transactional operations)
        <span class="cov8" title="1">newScoop := &amp;Scoop{
                client:     s.client,
                coll:       s.coll,
                filter:     NewCond(),
                sort:       bson.M{},
                projection: bson.M{},
                session:    s.session,
        }

        return newScoop, nil</span>
}

// Commit commits the transaction
func (s *Scoop) Commit() error <span class="cov8" title="1">{
        if s.session == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("no active transaction")
        }</span>

        <span class="cov8" title="1">err := s.session.CommitTransaction(context.Background())
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("err:%v", err)
                return err
        }</span>

        <span class="cov8" title="1">s.session.EndSession(context.Background())
        return nil</span>
}

// Rollback aborts/rolls back the transaction
func (s *Scoop) Rollback() error <span class="cov8" title="1">{
        if s.session == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("no active transaction")
        }</span>

        <span class="cov8" title="1">err := s.session.AbortTransaction(context.Background())
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("err:%v", err)
                return err
        }</span>

        <span class="cov8" title="1">s.session.EndSession(context.Background())
        return nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package mongo

import (
        "context"
        "fmt"

        "github.com/kamva/mgm/v3"
        "github.com/lazygophers/log"
        "go.mongodb.org/mongo-driver/bson"
        "go.mongodb.org/mongo-driver/mongo"
        "go.mongodb.org/mongo-driver/mongo/options"
)

// ChangeEvent represents a MongoDB change stream event
type ChangeEvent struct {
        OperationType            string                 `bson:"operationType"`
        FullDocument             map[string]interface{} `bson:"fullDocument"`
        DocumentKey              map[string]interface{} `bson:"documentKey"`
        UpdateDescription        map[string]interface{} `bson:"updateDescription"`
        Ns                       map[string]string      `bson:"ns"`
        ClusterTime              interface{}            `bson:"clusterTime"`
        TxnNumber                interface{}            `bson:"txnNumber"`
        Lsid                     interface{}            `bson:"lsid"`
        FullDocumentBeforeChange map[string]interface{} `bson:"fullDocumentBeforeChange"`
}

// ChangeStreamHandler is a function type for handling change stream events
type ChangeStreamHandler func(*ChangeEvent) error

// ChangeStream represents a MongoDB change stream watcher
type ChangeStream struct {
        coll   *mongo.Collection
        client *Client
}

// NewChangeStream creates a new change stream for a collection
func (s *Scoop) WatchChanges(pipeline ...bson.M) (*ChangeStream, error) <span class="cov8" title="1">{
        return &amp;ChangeStream{
                coll:   s.coll,
                client: s.client,
        }, nil
}</span>

// Watch watches for changes on the collection
func (cs *ChangeStream) Watch(pipeline ...bson.M) (*mongo.ChangeStream, error) <span class="cov8" title="1">{
        pipelineA := bson.A{}
        for _, stage := range pipeline </span><span class="cov8" title="1">{
                pipelineA = append(pipelineA, stage)
        }</span>

        <span class="cov8" title="1">opts := options.ChangeStream().SetFullDocument(options.UpdateLookup)

        stream, err := cs.coll.Watch(context.Background(), pipelineA, opts)
        if err != nil </span><span class="cov0" title="0">{
                cs.client.cfg.Logger.Errorf("err:%v", err)
                return nil, err
        }</span>

        <span class="cov8" title="1">return stream, nil</span>
}

// Listen listens for changes and calls the handler for each event
func (cs *ChangeStream) Listen(handler ChangeStreamHandler, pipeline ...bson.M) error <span class="cov8" title="1">{
        stream, err := cs.Watch(pipeline...)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer stream.Close(context.Background())

        for stream.Next(context.Background()) </span><span class="cov8" title="1">{
                var event ChangeEvent
                err := stream.Decode(&amp;event)
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("err:%v", err)
                        return err
                }</span>

                // Call the handler
                <span class="cov8" title="1">err = handler(&amp;event)
                if err != nil </span><span class="cov8" title="1">{
                        log.Errorf("err:%v", err)
                        return err
                }</span>
        }

        <span class="cov8" title="1">return stream.Err()</span>
}

// ListenWithFilters listens for changes matching the filter
func (cs *ChangeStream) ListenWithFilters(handler ChangeStreamHandler, operationTypes ...string) error <span class="cov8" title="1">{
        var pipelines []bson.M

        if len(operationTypes) &gt; 0 </span><span class="cov8" title="1">{
                // Filter by operation types
                filterOps := bson.A{}
                for _, op := range operationTypes </span><span class="cov8" title="1">{
                        filterOps = append(filterOps, op)
                }</span>

                <span class="cov8" title="1">pipelines = append(pipelines, bson.M{
                        "$match": bson.M{
                                "operationType": bson.M{
                                        "$in": filterOps,
                                },
                        },
                })</span>
        }

        <span class="cov8" title="1">return cs.Listen(handler, pipelines...)</span>
}

// Close closes the change stream
func (cs *ChangeStream) Close() <span class="cov8" title="1">{
        // Mark stream as closed for tracking/testing
        _ = cs.coll
        _ = cs.client
}</span>

// WatchAllCollections watches for changes across all collections in a database
func (c *Client) WatchAllCollections() (*DatabaseChangeStream, error) <span class="cov8" title="1">{
        return &amp;DatabaseChangeStream{
                client: c,
        }, nil
}</span>

// DatabaseChangeStream represents a change stream for an entire database
type DatabaseChangeStream struct {
        client *Client
}

// Watch watches for changes across all collections
func (dcs *DatabaseChangeStream) Watch(pipeline ...bson.M) (*mongo.ChangeStream, error) <span class="cov8" title="1">{
        pipelineA := bson.A{}
        for _, stage := range pipeline </span><span class="cov8" title="1">{
                pipelineA = append(pipelineA, stage)
        }</span>

        <span class="cov8" title="1">opts := options.ChangeStream().SetFullDocument(options.UpdateLookup)

        // Get database from MGM
        _, _, db, err := mgm.DefaultConfigs()
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("err:%v", err)
                return nil, err
        }</span>

        <span class="cov8" title="1">stream, err := db.Watch(context.Background(), pipelineA, opts)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("err:%v", err)
                return nil, err
        }</span>

        <span class="cov8" title="1">return stream, nil</span>
}

// Listen listens for database-wide changes
func (dcs *DatabaseChangeStream) Listen(handler ChangeStreamHandler, pipeline ...bson.M) error <span class="cov8" title="1">{
        stream, err := dcs.Watch(pipeline...)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer stream.Close(context.Background())

        for stream.Next(context.Background()) </span><span class="cov8" title="1">{
                var event ChangeEvent
                err := stream.Decode(&amp;event)
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("err:%v", err)
                        return err
                }</span>

                // Call the handler
                <span class="cov8" title="1">err = handler(&amp;event)
                if err != nil </span><span class="cov8" title="1">{
                        log.Errorf("err:%v", err)
                        return err
                }</span>
        }

        <span class="cov8" title="1">return stream.Err()</span>
}

// Close closes the change stream
func (dcs *DatabaseChangeStream) Close() <span class="cov8" title="1">{
        // Mark database change stream as closed for tracking/testing
        _ = dcs.client
}</span>

// PrintEvent is a simple event printer for debugging
func PrintEvent(event *ChangeEvent) error <span class="cov8" title="1">{
        fmt.Printf("Change Event: %+v\n", event)
        return nil
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package mongo

// Where creates a new Cond with AND conditions
func Where(args ...interface{}) *Cond <span class="cov8" title="1">{
        cond := &amp;Cond{}
        return cond.Where(args...)
}</span>

// OrWhere creates a new Cond with OR conditions
func OrWhere(args ...interface{}) *Cond <span class="cov8" title="1">{
        cond := &amp;Cond{}
        return cond.OrWhere(args...)
}</span>

// Or is an alias for OrWhere
func Or(args ...interface{}) *Cond <span class="cov8" title="1">{
        cond := &amp;Cond{}
        return cond.OrWhere(args...)
}</span>

// And creates a new Cond with AND conditions
func And(args ...interface{}) *Cond <span class="cov8" title="1">{
        cond := &amp;Cond{}
        return cond.Where(args...)
}</span>

// Equal creates a new Cond with equality condition
func Equal(column string, value interface{}) *Cond <span class="cov8" title="1">{
        cond := &amp;Cond{}
        return cond.Equal(column, value)
}</span>

// Ne creates a new Cond with != condition using $ne operator
func Ne(column string, value interface{}) *Cond <span class="cov8" title="1">{
        cond := &amp;Cond{}
        return cond.Ne(column, value)
}</span>

// Gt creates a new Cond with &gt; condition using $gt operator
func Gt(column string, value interface{}) *Cond <span class="cov8" title="1">{
        cond := &amp;Cond{}
        return cond.Gt(column, value)
}</span>

// Lt creates a new Cond with &lt; condition using $lt operator
func Lt(column string, value interface{}) *Cond <span class="cov8" title="1">{
        cond := &amp;Cond{}
        return cond.Lt(column, value)
}</span>

// Gte creates a new Cond with &gt;= condition using $gte operator
func Gte(column string, value interface{}) *Cond <span class="cov8" title="1">{
        cond := &amp;Cond{}
        return cond.Gte(column, value)
}</span>

// Lte creates a new Cond with &lt;= condition using $lte operator
func Lte(column string, value interface{}) *Cond <span class="cov8" title="1">{
        cond := &amp;Cond{}
        return cond.Lte(column, value)
}</span>

// In creates a new Cond with $in condition
func In(column string, values ...interface{}) *Cond <span class="cov8" title="1">{
        cond := &amp;Cond{}
        return cond.In(column, values...)
}</span>

// NotIn creates a new Cond with $nin condition
func NotIn(column string, values ...interface{}) *Cond <span class="cov8" title="1">{
        cond := &amp;Cond{}
        return cond.NotIn(column, values...)
}</span>

// Like creates a new Cond with LIKE condition
func Like(column string, value string) *Cond <span class="cov8" title="1">{
        cond := &amp;Cond{}
        return cond.Like(column, value)
}</span>

// LeftLike creates a new Cond with LEFT LIKE condition (pattern%)
func LeftLike(column string, value string) *Cond <span class="cov8" title="1">{
        cond := &amp;Cond{}
        return cond.LeftLike(column, value)
}</span>

// RightLike creates a new Cond with RIGHT LIKE condition (%pattern)
func RightLike(column string, value string) *Cond <span class="cov8" title="1">{
        cond := &amp;Cond{}
        return cond.RightLike(column, value)
}</span>

// NotLike creates a new Cond with NOT LIKE condition
func NotLike(column string, value string) *Cond <span class="cov8" title="1">{
        cond := &amp;Cond{}
        return cond.NotLike(column, value)
}</span>

// NotLeftLike creates a new Cond with NOT LEFT LIKE condition
func NotLeftLike(column string, value string) *Cond <span class="cov8" title="1">{
        cond := &amp;Cond{}
        return cond.NotLeftLike(column, value)
}</span>

// NotRightLike creates a new Cond with NOT RIGHT LIKE condition
func NotRightLike(column string, value string) *Cond <span class="cov8" title="1">{
        cond := &amp;Cond{}
        return cond.NotRightLike(column, value)
}</span>

// Between creates a new Cond with BETWEEN condition
func Between(column string, min, max interface{}) *Cond <span class="cov8" title="1">{
        cond := &amp;Cond{}
        return cond.Between(column, min, max)
}</span>

// NotBetween creates a new Cond with NOT BETWEEN condition
func NotBetween(column string, min, max interface{}) *Cond <span class="cov8" title="1">{
        cond := &amp;Cond{}
        return cond.NotBetween(column, min, max)
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
